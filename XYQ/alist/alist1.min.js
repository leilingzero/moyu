import {
    distance
} from "./mod.js";
import {
    sortListByCN
} from "./sortName.js";
import cheerio from "assets://js/lib/cheerio.min.js"
String.prototype.rstrip = function (chars) {
    let regex = new RegExp(chars + "$");
    return this.replace(regex, "")
};
var showMode = "single";
var searchDriver = "";
var search_type = "";
var detail_order = "name";
var __poster_mode = true;
var __filter_data = null;
let __filter = false;
let __extend = null;
let __imageSource = '@Referer=https://api.douban.com/@User-Agent=Mozilla/5.0%20(Windows%20NT%2010.0;%20Win64;%20x64)%20AppleWebKit/537.36%20(KHTML,%20like%20Gecko)%20Chrome/113.0.0.0%20Safari/537.36';
const __folder_img = "https://pic.616pic.com/ys_bnew_img/00/46/91/Kduke9oSev.jpg";
const __play_list_img = "https://pic.616pic.com/ys_bnew_img/00/24/42/xp3ozLGSm4.jpg";
const __num = "200";
let __proxy = "null";
const request_timeout = 10000;
const VERSION = "alist v2/v3 202407121256";

function print(any) {
    any = any || "";
    if (typeof any == "object" && Object.keys(any).length > 0) {
        try {
            any = JSON.stringify(any);
            console.log(any)
        } catch (e) {
            console.log(typeof any + ":" + any.length)
        }
    } else if (typeof any == "object" && Object.keys(any).length < 1) {
        console.log("null object")
    } else {
        console.log(any)
    }
}
const http = function (url, options = {}, noAuth = false, timeout = request_timeout) {
    if (options.method === "POST" && options.data) {
        options.body = JSON.stringify(options.data);
        options.headers = Object.assign({
            "content-type": "application/json"
        }, options.headers);
        if (!noAuth) {
            options.headers = Object.assign({
                'Authorization': 'alist-09ceb38a-f143-47f7-b255-c3eec819cd7bbJIVJ9xmnzb1g0OXlaJtTB9mVwEU4f7e91crPXeY2DetLPwojSPpY6OUOiY8UyPx'
            }, options.headers);
        }
    }
    options.timeout = timeout;
    try {
        const res = req(url, options);
        res.json = () => res && res.content ? JSON.parse(res.content) : null;
        res.text = () => res && res.content ? res.content : "";
        return res
    } catch (e) {
        return {
            json() {
                return null
            },
            text() {
                return ""
            }
        }
    }
};
["get", "post"].forEach(method => {
    http[method] = function (url, options = {}, noAuth = false, timeout = request_timeout) {
        return http(url, Object.assign(options, {
            method: method.toUpperCase()
        }), noAuth, timeout)
    }
});
const __drives = {};

function isMedia(file) {
    return /\.(dff|dsf|mp3|aac|wav|wma|cda|flac|m4a|mid|mka|mp2|mpa|mpc|ape|ofr|ogg|ra|wv|tta|ac3|dts|tak|webm|wmv|mpeg|mov|ram|swf|mp4|avi|rm|rmvb|flv|mpg|mkv|m3u8|ts|3gp|asf|iso)$/.test(file.toLowerCase())
}

function get_drives_path(tid) {
    const index = tid.indexOf("$");
    const name = tid.substring(0, index);
    const path = tid.substring(index + 1);
    return {
        drives: get_drives(name),
        path: path
    }
}

function get_drives(name) {
    const {
        settings,
        api,
        server
    } = __drives[name];
    if (settings.v3 == null) {
        settings.title = "小雅的分类 Alist";
        settings.v3 = true;
        settings.version = "小雅魔改版";
        settings.enableSearch = false
        api.path = settings.v3 ? "/api/fs/list" : "/api/public/path";
        api.file = settings.v3 ? "/api/fs/get" : "/api/public/path";
        api.search = settings.v3 ? "/api/public/search" : "/api/public/search"
    }
    return __drives[name]
}

function get_proxy() {
    try {
        //let data = http.get("http://127.0.0.1:9988" + "/proxy?do=genck").text();
        //if (data !== "ok") {
        //return "";
        //}
        let data = http.get("http://127.0.0.1:9988" + "/proxy?do=gen&url=" + __drives[searchDriver].server).text();
        const regex = /Alist/g;
        if (!regex.test(data)) {
            return "";
        }
        return "http://127.0.0.1:9988" + "/proxy?do=gen";
    } catch {
        return "";
    }
}

function init(ext) {
    console.log("当前版本号:" + VERSION);
    let data;
    if (typeof ext == "object") {
        data = ext;
        print("alist ext:object")
    } else if (typeof ext == "string") {
        if (ext.startsWith("http")) {
            let alist_data = ext.split(";");
            let alist_data_url = alist_data[0];
            search_type = alist_data.length > 2 ? alist_data[2] : search_type;
            print(alist_data_url);
            data = http.get(alist_data_url).json()
        } else {
            print("alist ext:json string");
            data = JSON.parse(ext)
        }
    }
    let drives = [];
    if (Array.isArray(data) && data.length > 0 && data[0].hasOwnProperty("server") && data[0].hasOwnProperty("name")) {
        drives = data
    } else if (!Array.isArray(data) && data.hasOwnProperty("drives") && Array.isArray(data.drives)) {
        drives = data.drives.filter(it => it.type && it.type === "alist" || !it.type)
    }
    print(drives);
    __poster_mode = true;
    searchDriver = (drives.find(x => x.search) || {}).name || "";
    if (!searchDriver && drives.length > 0) {
        searchDriver = drives[0].name
        __poster_mode = false;
    }
    print(searchDriver);
    drives.forEach(item => {
        let _path_param = [];
        if (item.params) {
            _path_param = Object.keys(item.params);
            _path_param.sort((a, b) => a.length - b.length)
        }
        let servers = item.server.split(";");
        servers.forEach((server, index, array) => {
            array[index] = server.replace(/\/$/, '');
        });
        let server = servers[0];
        __drives[item.name] = {
            name: item.name,
            server: server,
            servers: servers,
            startPage: item.startPage || "/",
            showAll: item.showAll === true,
            search: !!item.search,
            noAuth: !!item.noAuth,
            noPoster: !!item.noPoster,
            pathByApi: !!item.pathByApi,
            isPreview: !!item.isPreview,
            params: item.params || {},
            _path_param: _path_param,
            settings: {},
            api: {},
            isFullList: false,
            getParams(path) {
                const key = this._path_param.find(x => path.startsWith(x));
                return Object.assign({}, this.params[key], {
                    path: path
                })
            },
            getPath(path) {
                try {
                    const res = http.post(this.server + this.api.path, {
                        data: this.getParams(path)
                    }, this.noAuth, 5000);
                    return this.settings.v3 ? res.json().data.content : res.json().data.files;
                } catch (error) {
                }

                for (const server of this.servers) {
                    try {
                        if (server !== this.server) {
                            const res = http.post(server + this.api.path, {
                                data: this.getParams(path)
                            }, this.noAuth, 5000);

                            this.server = server;
                            return this.settings.v3 ? res.json().data.content : res.json().data.files;
                        }
                    } catch (error) {
                    }
                }

                return null;
            },
            getFile(path) {
                if (__proxy === "null") {
                    __proxy = get_proxy();
                }
                let proxy = "";
                if (__proxy !== "" && path.includes("夸克")) {
                    proxy = __proxy + "&size=500000&thread=16&url="
                }
                let raw_url = this.server + "/d" + path;
                raw_url = proxy + encodeURI(raw_url);
                let previewSuccess = false;
                try {
                    if (isMedia(path) && this.isPreview) {
                        const res = http.post(this.server + "/api/fs/other", {
                            data: Object.assign({}, this.getParams(path), { method: "video_preview" })
                        }).json();
                        let urls = res.data.video_preview_play_info.live_transcoding_task_list;
                        raw_url = urls[urls.length - 1].url;
                        previewSuccess = true;
                    }
                }
                catch (e) {
                    previewSuccess = false;
                    raw_url = this.server + "/d" + path;
                    raw_url = encodeURI(raw_url);
                }

                if (!previewSuccess && this.pathByApi) {
                    const res = http.post(this.server + "/api/fs/get", {
                        data: this.getParams(path)
                    }, this.noAuth).json();
                    raw_url = res.data.raw_url;
                }

                return {
                    raw_url: raw_url
                }
            },
            isFolder(data) {
                return data.type === 1
            },
            isVideo(data) {
                return this.settings.v3 ? data.type === 2 || data.type === 0 || data.type === 3 : data.type === 3 || data.type === 0 || data.type === 4
            },
            is_subt(data) {
                if (data.type === 1) {
                    return false
                }
                const ext = /\.(srt|ass|scc|stl|ttml)$/;
                return ext.test(data.name)
            },
            getPic(data) {
                let pic = this.settings.v3 ? data.thumb : data.thumbnail;
                return pic || (this.isFolder(data) ? __folder_img : "")
            },
            getTime(data, isStandard) {
                isStandard = isStandard || false;
                try {
                    let tTime = data.updated_at || data.time_str || data.modified || "";
                    let date = "";
                    if (tTime) {
                        tTime = tTime.split("T");
                        date = tTime[0];
                        if (isStandard) {
                            date = date.replace(/-/g, "/")
                        }
                        tTime = tTime[1].split(/Z|\./);
                        date += " " + tTime[0]
                    }
                    return date
                } catch (e) {
                    return ""
                }
            }
        }
    });
    try {
        __filter_data = http.get(__drives[searchDriver].server + "/tvbox/json/alist.filters.json").json().startPages;
    } catch (e) {
        __filter_data = null;
    }
    print("init执行完毕")
}

function genFilters(tid) {
    let {
        drives,
        path
    } = get_drives_path(tid);
    if (!__poster_mode) {
        return [];
    }
    if (drives.noPoster) {
        return [{
            key: "order",
            name: "排序：",
            value: [{
                n: "默认排序",
                v: "name_asc"
            }, {
                n: "名字降序",
                v: "name_desc"
            }, {
                n: "时间降序",
                v: "time_desc"
            }, {
                n: "时间升序",
                v: "time_asc"
            }]
        }];
    }
    let values = [{
        n: "全部分类",
        v: "all"
    }];
    try {
        var data = __filter_data;
        data = data.find(it => it.startPage === path).names;
        data.forEach(item => {
            let subpath = item;
            values.push({
                n: subpath,
                v: subpath
            });
        });
    } catch (e) {
        try {
            const list = drives.getPath(path);
            list.forEach(item => {
                if (drives.isFolder(item)) {
                    let subpath = item.name;
                    values.push({
                        n: subpath,
                        v: subpath
                    });
                }
            });
        } catch (e) { }
    }

    let filters = [{
        key: "subpath",
        name: "分类：",
        value: values
    }, {
        key: "douban",
        name: "豆瓣评分：",
        value: [{
            n: "全部评分",
            v: "0"
        }, {
            n: "9分以上",
            v: "9"
        }, {
            n: "8分以上",
            v: "8"
        }, {
            n: "7分以上",
            v: "7"
        }, {
            n: "6分以上",
            v: "6"
        }, {
            n: "5分以上",
            v: "5"
        }]
    }, {
        key: "doubansort",
        name: "豆瓣排序：",
        value: [{
            n: "原始顺序",
            v: "0"
        }, {
            n: "豆瓣评分\u2B07\uFE0F",
            v: "1"
        }, {
            n: "豆瓣评分\u2B06\uFE0F",
            v: "2"
        }]
    }, {
        key: "random",
        name: "随机显示：",
        value: [{
            n: "固定显示",
            v: "0"
        }, {
            n: "随机显示️",
            v: "9999999999"
        }, {
            n: "随机200个️",
            v: "200"
        }, {
            n: "随机500个️",
            v: "500"
        }]
    }];

    return filters;
}

function home(filter) {
    let classes = Object.keys(__drives).map(key => ({
        type_id: `${key}$${__drives[key].startPage}`,
        type_name: key,
        type_flag: __drives[key].startPage === "/" || !__poster_mode || __drives[key].noPoster ? "1" : "2"
    }));
    let filter_dict = {};
    classes.forEach(it => {
        filter_dict[it.type_id] = genFilters(it.type_id);
    });
    print("----home----");
    print(classes);
    return JSON.stringify({
        class: classes,
        filters: filter_dict
    })
}

function homeVod(params) {
    if (!searchDriver) {
        return JSON.stringify({
            list: []
        })
    } else {
        let driver = __drives[searchDriver];
        driver.vods = getAllVods("type=daily&filter=last&num=" + __num, driver.name).list;
        return JSON.stringify({
            list: driver.vods
        });
    }
}

function parseSou(htmlContent) {
    const regex = /<a\s+href=([^>]*)>/g;
    let matches = [];
    let match;
    while ((match = regex.exec(htmlContent)) !== null) {
        if (match[1] === "/" || match[1] === "https://t.me/xiaoya_media") {
            continue;
        }
        matches.push(match[1]);
    }
    return matches;
}

function getAllVods(para, drivename, pg = "0", filter = false, extend = {}) {
    let driver = __drives[drivename];
    let orgdrive = __drives[drivename];
    let surl = driver.server + "/sou?" + para + "&type=video&num=" + __num;

    let fl = filter ? extend : {};
    let isflmode = !!fl.subpath || !!fl.doubansort || !!fl.douban || !!fl.random;
    let fullList = false;
    pg = parseInt(pg);

    if (!pg || pg > 1 || isflmode) {
        surl = driver.server + "/sou?" + para + "&type=video";
        fullList = true;
    }

    if (orgdrive.name === "每日更新") {
        surl = driver.server + "/sou?filter=last&num=" + "100000" + "&type=daily";
    }

    if (pg === 1 && !isflmode && orgdrive.name === "每日更新") {
        surl = driver.server + "/sou?filter=last&num=" + __num + "&type=daily";
    }

    if (orgdrive.startPage !== "/") {
        if (orgdrive.isFullList || (!fullList && orgdrive.vods != null)) {
            return {
                list: orgdrive.vods
            };
        }
    }
    else {
        orgdrive.isFullList = true;
    }

    let html = http.get(surl).text();
    let lists = parseSou(html);
    let vods = [];
    let vods_pikpak = [];
    let vods_115 = [];
    let vods_quark = [];
    let vods_ali = [];
    let excludeReg = /\.(pdf|epub|mobi|txt|doc|lrc)$/;
    let pikpakRegex = /pikpak/;
    let my115Regex = /115/;
    let quarkRegex = /夸克/;
    let cnt = 0;
    lists.forEach(it => {
        let isPikpak = false;
        let is115 = false;
        let isquark = false;
        let vhref = it;
        if (vhref) {
            vhref = unescape(vhref)
        }
        if (excludeReg.test(vhref.toLowerCase())) {
            return
        }
        if (pikpakRegex.test(vhref.toLowerCase())) {
            isPikpak = true;
        }
        if (my115Regex.test(vhref.toLowerCase())) {
            is115 = true;
        }
        if (quarkRegex.test(vhref.toLowerCase())) {
            isquark = true;
        }
        const parts = vhref.split('#')
        if (parts.length >= 2) {
            vhref = parts[0]
        }
        cnt++;
        let vid = __drives[drivename].name + "$" + vhref + "#search#";
        if (showMode === "all") {
            vid += "#all#"
        }

        let have_pic = 0;
        let vod_dbid = "";
        let poster = '';
        let douban_rate = '';
        let display_path = '';
        if (parts.length >= 5) {
            let uri_parts = parts[4].split('://')
            poster = parts[4] + __imageSource;
            if (uri_parts[1]) {
                have_pic = 1;
            }
        }
        else {
            // return
        }

        if (parts.length >= 4) {
            douban_rate = parts[3];
        }
        if (parts.length >= 3) {
            vod_dbid = parts[2];
        }
        if (parts.length < 2) {
            //如果以/结束，则取/前面作为显示名
            let path_list = parts[0].replace(/\/$/g, "").split('/');
            display_path = path_list[path_list.length - 1];
        }

        vods = vods_ali;
        if (isPikpak) {
            vods = vods_pikpak;
        }
        if (is115) {
            //vods = vods_115;
        }
        if (isquark) {
            //vods = vods_quark;
        }

        let icons = ""
        if (isPikpak) {
            icons = "pikpak";
        }
        if (is115) {
            icons = "115";
        }
        if (isquark) {
            icons = "夸克";
        }
        if (parts[0].includes("套娃")) {
            icons = "套娃";
        }

        vods.push({
            vod_id: vid,
            vod_dbid: vod_dbid,
            vod_name: parts.length < 2 ? display_path : parts[1],
            vod_tag: "file",
            vod_pic: have_pic ? poster : "http://img.xiaoya.pro/xiaoya.jpg",
            vod_remarks: douban_rate == '' ? icons : "豆瓣:" + douban_rate + ' ' + icons,
            vod_fullpath: parts[0],
            vod_poster: have_pic
        });
    });

    vods = vods_ali.concat(vods_pikpak).concat(vods_115).concat(vods_quark);
    if (!orgdrive.isFullList) {
        orgdrive.isFullList = fullList;
    }

    let vods_poster = vods.filter(it => it.vod_poster);
    let vods_none_poster = vods.filter(it => !it.vod_poster);

    vods = vods_poster.concat(vods_none_poster);
    orgdrive.vods = vods;

    return {
        list: vods
    }
}

function removeDuplicates(arr) {
    const seen = new Set();

    return arr.filter((item) => {
        const itemString = JSON.stringify(item);
        if (!seen.has(itemString)) {
            seen.add(itemString);
            return true;
        }
        return false;
    });
}

function root_category(tid, pg, filter, extend) {
    let vods = [];
    let orid = tid.replace(/#all#|#search#/g, "");
    let {
        drives,
        path
    } = get_drives_path(orid);

    drives.vods = getAllVods("box=" + path, drives.name, pg, filter, extend).list

    let fullpath = path;
    let fl = filter ? extend : {};
    if (fl.subpath && fl.subpath !== "all") {
        fullpath = path + "/" + fl.subpath;
    }
    drives.vods.forEach(it => {
        const pattern = new RegExp("^" + fullpath);
        if (!pattern.test(it.vod_fullpath)) {
            return
        }
        vods.push(it);
    });

    let douban = 0;
    if (fl.douban) {
        douban = parseFloat(fl.douban);
    }

    let highRatedVods = vods.filter(vod => {
        var ratingString = vod.vod_remarks.replace("豆瓣:", "").trim();
        return (parseFloat(ratingString) || 0) >= douban;
    });
    vods = highRatedVods;

    if (fl.doubansort && fl.doubansort === "1") {
        vods.sort((a, b) => {
            const ratingA = parseFloat(a.vod_remarks.replace("豆瓣:", "").trim()) || 0;
            const ratingB = parseFloat(b.vod_remarks.replace("豆瓣:", "").trim()) || 0;
            return ratingB - ratingA;
        });
    }

    if (fl.doubansort && fl.doubansort === "2") {
        vods.sort((a, b) => {
            const ratingA = parseFloat(a.vod_remarks.replace("豆瓣:", "").trim()) || 0;
            const ratingB = parseFloat(b.vod_remarks.replace("豆瓣:", "").trim()) || 0;
            return ratingA - ratingB;
        });
    }

    let random = 0;
    if (fl.random) {
        random = parseInt(fl.random);
    }

    if (random !== 0) {
        let keepsequence = (fl.doubansort && fl.doubansort !== "0");
        vods = getRandomElements(vods, random, keepsequence);
    }

    return JSON.stringify({
        page: 1,
        pagecount: drives.isFullList ? 1 : 2,
        //pagecount: 2,
        //limit: vods.length,
        //total: vods.length,
        list: vods
    })
}

function getRandomElements(arr, count, keepsequence) {
    if (arr.length <= count) {
        if (keepsequence) {
            return arr.slice();
        } else {
            const shuffledArray = arr.slice();
            for (let i = shuffledArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
            }
            return shuffledArray;
        }
    }

    const randomIndexes = [];
    const selectedIndexes = new Set();

    while (randomIndexes.length < count) {
        const index = Math.floor(Math.random() * arr.length);

        if (!selectedIndexes.has(index)) {
            selectedIndexes.add(index);
            randomIndexes.push(index);
        }
    }

    if (keepsequence) {
        randomIndexes.sort((a, b) => a - b);
    }

    const result = randomIndexes.map(index => arr[index]);

    return result;
}

function category(tid, pg, filter, extend) {
    let orid = tid.replace(/#all#|#search#/g, "");
    let {
        drives,
        path
    } = get_drives_path(orid);

    if (__poster_mode && !drives.noPoster && path !== "/" && path === drives.startPage) {
        return root_category(tid, pg, filter, extend);
    }

    const id = orid.endsWith("/") ? orid : orid + "/";
    let list = null;
    if (!filter && extend.list) {
        list = extend.list;
    } else {
        list = drives.getPath(path);
    }
    let subList = [];
    let vodFiles = [];
    let allList = [];
    __filter = filter;
    __extend = extend;
    let fl = filter ? extend : {};
    if (fl.show) {
        showMode = fl.show
    }
    list.forEach(item => {
        if (drives.is_subt(item)) {
            subList.push(item.name)
        }

        if (!drives.isFolder(item) && !/\.(dff|dsf|mp3|aac|wav|wma|cda|flac|m4a|mid|mka|mp2|mpa|mpc|ape|ofr|ogg|ra|wv|tta|ac3|dts|tak|webm|wmv|mpeg|mov|ram|swf|mp4|avi|rm|rmvb|flv|mpg|mkv|m3u8|ts|3gp|asf|iso)$/.test(item.name)) {
            return
        }
        if (!drives.showAll && !drives.isFolder(item) && !drives.isVideo(item)) {
            return
        }
        let vod_time = drives.getTime(item);
        let vod_size = get_size(item.size);
        let remark = vod_time.split(" ")[0].substr(3) + "\t" + vod_size;
        let vod_id = id + item.name + (drives.isFolder(item) ? "/" : "");
        if (showMode === "all") {
            vod_id += "#all#"
        }
        print(vod_id);
        const vod = {
            vod_id: vod_id,
            vod_name: item.name.replaceAll("$", "").replaceAll("#", ""),
            vod_pic: drives.getPic(item),
            vod_time: vod_time,
            vod_size: item.size,
            vod_tag: drives.isFolder(item) ? "folder" : "file",
            // vod_tag: "file",
            vod_remarks: drives.isFolder(item) ? remark + " 文件夹" : remark
        };
        if (drives.isVideo(item)) {
            vodFiles.push(vod)
        }
        allList.push(vod)
    });
    if (vodFiles.length === 1 && subList.length > 0) {
        let sub;
        if (subList.length === 1) {
            sub = subList[0]
        } else {
            let subs = JSON.parse(JSON.stringify(subList));
            subs.sort((a, b) => {
                let a_similar = (a.includes("chs") ? 100 : 0) + levenshteinDistance(a, vodFiles[0].vod_name);
                let b_similar = (b.includes("chs") ? 100 : 0) + levenshteinDistance(b, vodFiles[0].vod_name);
                if (a_similar > b_similar) {
                    return 1
                } else {
                    return -1
                }
            });
            sub = subs.slice(-1)[0]
        }
        vodFiles[0].vod_id += "@@@" + sub;
        vodFiles[0].vod_remarks += "\u1F3F7"
    } else {
        vodFiles.forEach(item => {
            var lh = 0;
            let sub;
            subList.forEach(s => {
                const l = levenshteinDistance(s, item.vod_name);
                if (l > 60 && l > lh) {
                    sub = s
                    lh = l;
                }
            });
            if (sub) {
                item.vod_id += "@@@" + sub;
                item.vod_remarks += "\u1F3F7"
            }
        })
    }
    if (fl.order) {
        let key = fl.order.split("_").slice(0, -1).join("_");
        let order = fl.order.split("_").slice(-1)[0];
        print(`排序key:${key},排序order:${order}`);
        if (key.includes("name")) {
            detail_order = "name";
            allList = sortListByName(allList, "vod_name", order)
        } else if (key.includes("cn")) {
            detail_order = "cn";
            allList = sortListByCN(allList, "vod_name", order)
        } else if (key.includes("time")) {
            detail_order = "time";
            allList = sortListByTime(allList, key, order)
        } else if (key.includes("size")) {
            detail_order = "size";
            allList = sortListBySize(allList, key, order)
        } else if (fl.order.includes("none")) {
            detail_order = "none";
            print("不排序")
        }
    } else {
        if (detail_order !== "none") {
            allList = sortListByName(allList, "vod_name", "asc")
        }
    }
    if (pg && vodFiles.length > 1) {
        const vod = {
            vod_id: id + "~playlist",
            vod_name: "播放列表",
            vod_pic: __play_list_img,
            vod_tag: "file",
            vod_remarks: "共" + vodFiles.length + "集"
        };
        allList.unshift(vod)
    }
    print("----category----" + `tid:${tid},detail_order:${detail_order},showMode:${showMode}`);
    return JSON.stringify({
        page: 1,
        pagecount: 1,
        limit: allList.length,
        total: allList.length,
        list: allList
    })
}

function getAll(otid, tid, drives, path, ls = null, nopic = false, filter = false, extend = null) {
    try {
        let content = null;
        if (!filter) {
            content = category(tid, null, false, { list: ls });
        } else {
            content = category(tid, null, filter, extend);
        }
        const isFile = isMedia(otid.replace(/#all#|#search#/g, "").split("@@@")[0]);
        const {
            list
        } = JSON.parse(content);
        let vod_play_url = [];
        list.forEach(x => {
            if (x.vod_tag === "file") {
                let vid = x.vod_id.replace(/#all#|#search#/g, "");
                vod_play_url.push(`${x.vod_name}$${drives.name}~~~${vid.substring(vid.indexOf("$") + 1)}`)
            }
        });
        const pl = path.split("/").filter(it => it);
        let vod_name = pl[pl.length - 1] || drives.name;
        if (vod_name === drives.name) {
            print(pl)
        }
        if (otid.includes("#search#")) {
            // vod_name += "[搜]"
        }

        let orvod = nopic ? null : findVodById(drives, tid);

        let vod_pic = orvod !== null ? orvod.vod_pic : "https://avatars.githubusercontent.com/u/97389433?s=120&v=4";

        let vod = {
            vod_id: otid,
            vod_name: vod_name,
            type_name: "文件夹",
            vod_pic: vod_pic,
            vod_content: tid,
            vod_tag: isFile ? "file" : "folder",
            vod_play_from: drives.name,
            vod_play_url: vod_play_url.join("#"),
            vod_remarks: drives.settings.title
        };
        print("----detail1----");
        print(vod);
        return JSON.stringify({
            list: [vod]
        })
    } catch (e) {
        print(e.message);
        return JSON.stringify({
            list: [{}]
        })
    }
}

function playlist(otid, tid, drives, path, filter = false, extend = null) {
    tid = tid.replace('/~playlist', '')
    otid = otid.replace('/~playlist', '')
    path = path.replace('/~playlist', '')
    return getAll(otid, tid, drives, path, null, false, filter, extend)
}

function findVodById(drives, targetVodId) {

    targetVodId = targetVodId.replace(/#all#|#search#/g, "");
    let foundVod = null;

    // 使用 Array.find 查找元素
    if (drives !== null && drives.vods != null) {
        foundVod = drives.vods.find(vod => vod.vod_id.replace(/#all#|#search#/g, "") === targetVodId);
    }

    if (!foundVod) {
        try {
            const result = get_drives_path(targetVodId);
            let driver = drives;
            let path = result.path;
            let wd = path.substring(0, 30).replace(/[!"#$%&'()*+,\-.:;<=>?@[\\\]^_`{|}~]/g, ' ');
            if (wd !== "/" && !drives.noPoster) {
                foundVod = getAllVods("box=" + wd, driver.name).list.find(vod => {
                    let r = get_drives_path(vod.vod_id.replace(/#all#|#search#/g, ""));
                    return path === r.path;
                });
            }
        } catch (e) {
            foundVod = null;
        }
    }

    return foundVod || null;
}

function isPathFolder(path) {
    return !(/\.(dff|dsf|mp3|aac|wav|wma|cda|flac|m4a|mid|mka|mp2|mpa|mpc|ape|ofr|ogg|ra|wv|tta|ac3|dts|tak|webm|wmv|mpeg|mov|ram|swf|mp4|avi|rm|rmvb|flv|mpg|mkv|m3u8|ts|3gp|asf|nfo|iso)$/.test(path.toLowerCase()));
}

function genFolderPlayList(drives, path, url, from) {
    let vod_play_url = url;
    let vod_play_from = from;
    let subFolderList = [];
    try {
        let list = drives.getPath(path);
        list.forEach(item => {
            if (!drives.isFolder(item)) {
                return
            }
            subFolderList.push(item.name)
        });

        var searchurl = drives.name + "$" + path;
        var tempvod = getAll(searchurl + "#search#", searchurl, drives, "/" + path, list, true);
        if (JSON.parse(tempvod).list[0].vod_play_url != "") {
            vod_play_url = vod_play_url + "$$$" + JSON.parse(tempvod).list[0].vod_play_url;
            vod_play_from = vod_play_from + "$$$" + path.substring(path.lastIndexOf("/") + 1);
        }
    }
    catch (e) {
        vod_play_url = url;
        vod_play_from = from;
    }

    subFolderList.forEach(item => {
        const result = genFolderPlayList(drives, path + "/" + item, vod_play_url, vod_play_from);
        vod_play_url = result.vod_play_url;
        vod_play_from = result.vod_play_from;
    });

    return {
        vod_play_url: vod_play_url,
        vod_play_from: vod_play_from
    };
}

function getDoubanInfo(id) {
    try {
        if (id === "") {
            return {};
        }
        const url = "https://movie.douban.com/subject/" + id + "/";
        let html = http.get(url).text();
        const $ = cheerio.load(html);
        let plot = $('#link-report-intra span[property="v:summary"]').text().trim();
        const yearElement = $('.year');
        let year = yearElement.text().replace(/\(|\)/g, '');
        let region = "";
        var text = html;
        var regex = /<span class="pl">制片国家\/地区:<\/span>[\s\n]*([^<]+)/;
        var match = text.match(regex);
        if (match && match[1]) {
            region = match[1].trim();
        }
        const actorElements = $('meta[property^="video:actor"]');
        let actors = actorElements.map((index, element) => {
            return $(element).attr('content');
        }).get();
        actors = actors.join('/');
        const directorElement = $('meta[property="video:director"]');
        const director = directorElement.attr('content');
        const genreElement = $('span.pl:contains("类型:")');
        const type = genreElement.nextAll('span[property="v:genre"]').map((index, element) => {
            return $(element).text();
        }).get().join('/');

        return {
            plot,
            year,
            region,
            actors,
            director,
            type
        };
    } catch (e) {
        return {};
    }
}

function getFolderVodDetail(tid) {
    let orid = tid.replace(/#all#|#search#/g, "");
    let {
        drives,
        path
    } = get_drives_path(orid);

    if (!isPathFolder(path.toLowerCase())) {
        return "";
    }

    if (path.endsWith("/~playlist")) {
        return "";
    }

    //index文件中有些文件夹以/结尾，兼容历史代码
    path = path.replace(/\/$/g, "");
    tid = tid.replace(/\/$/g, "");
    orid = orid.replace(/\/$/g, "");

    let orvod = findVodById(drives, tid);
    let vod_pic = orvod !== null ? orvod.vod_pic : "https://avatars.githubusercontent.com/u/97389433?s=120&v=4";

    let {
        vod_play_url,
        vod_play_from
    } = genFolderPlayList(drives, path, "", "");
    vod_play_from = vod_play_from.replace(/^[$]{3}/, '');
    vod_play_url = vod_play_url.replace(/^[$]{3}/, '');

    let doubanInfo = {};
    let vod_name = path.substring(path.lastIndexOf("/") + 1);
    if (orvod) {
        vod_name = orvod.vod_name;
        doubanInfo = getDoubanInfo(orvod.vod_dbid);
    }
    let vod_content = doubanInfo.plot ? doubanInfo.plot + "      \n\n文件路径：" + path : path;
    let vod = {
        vod_id: orid,
        vod_name: vod_name,
        type_name: doubanInfo.type,
        vod_pic: vod_pic,
        vod_content: vod_content,
        vod_actor: doubanInfo.actors,
        vod_area: doubanInfo.region,
        vod_director: doubanInfo.director,
        vod_year: doubanInfo.year,
        vod_play_from: vod_play_from,
        vod_play_url: vod_play_url,
        vod_remarks: drives.settings.title
    };

    return JSON.stringify({
        list: [vod]
    })
}

function detail(tid) {
    let folderVod = getFolderVodDetail(tid.split("@@@")[0]);
    if (folderVod !== "") {
        return folderVod;
    }
    let isSearch = tid.includes("#search#");
    let isAll = tid.includes("#all#");
    let otid = tid;
    tid = tid.replace(/#all#|#search#/g, "");
    let isFile = isMedia(tid.split("@@@")[0]);
    print(`isFile:${tid}?${isFile}`);
    let {
        drives,
        path
    } = get_drives_path(tid);
    print(`drives:${drives},path:${path}`);

    if (path.endsWith("/")) {
        return getAll(otid, tid, drives, path)
    } else if (path.endsWith("/~playlist")) {
        return playlist(otid, tid, drives, path, __filter, __extend)
    } else {
        if (isSearch && !isFile) {
            return getAll(otid, tid, drives, path)
        } else if (isAll) {
            let new_tid;
            if (isFile) {
                new_tid = tid.split("/").slice(0, -1).join("/") + "/"
            } else {
                new_tid = tid
            }
            print(`全集模式 tid:${tid}=>tid:${new_tid}`);
            let {
                drives,
                path
            } = get_drives_path(new_tid);
            return getAll(otid, new_tid, drives, path)
        } else if (isFile) {
            let paths = path.split("@@@");
            let orvod = findVodById(drives, tid);
            let vod_pic = orvod !== null ? orvod.vod_pic : "https://avatars.githubusercontent.com/u/97389433?s=120&v=4";

            let doubanInfo = {};
            let vod_name = paths[0].substring(paths[0].lastIndexOf("/") + 1);
            if (orvod) {
                vod_name = orvod.vod_name;
                doubanInfo = getDoubanInfo(orvod.vod_dbid);
            }
            let vod_content = doubanInfo.plot ? doubanInfo.plot + "      \n\n文件路径：" + paths[0] : paths[0];

            let vod = {
                vod_id: otid,
                vod_name: vod_name,
                type_name: doubanInfo.type,
                vod_pic: vod_pic,
                vod_content: vod_content,
                vod_actor: doubanInfo.actors,
                vod_area: doubanInfo.region,
                vod_director: doubanInfo.director,
                vod_year: doubanInfo.year,
                vod_play_from: drives.name,
                vod_play_url: vod_name + "$" + drives.name + "~~~" + path,
                vod_remarks: drives.settings.title
            };
            print("----detail2----");
            print(vod);
            return JSON.stringify({
                list: [vod]
            })
        } else {
            return JSON.stringify({
                list: []
            })
        }
    }
}

function play(flag, id, flags) {
    if (__drives[flag] == null) {
        //flag = __drives[searchDriver].name;
    }
    let urls = id.split("@@@");
    flag = urls[0].split("~~~")[0];
    urls[0] = urls[0].split("~~~")[1];
    const drives = get_drives(flag);
    let vod = {
        parse: 0,
        playUrl: "",
        url: drives.getFile(urls[0]).raw_url
    };
    if (urls.length >= 2) {
        const path = urls[0].substring(0, urls[0].lastIndexOf("/") + 1);
        vod.subt = drives.getFile(path + urls[1]).raw_url
    }
    print("----play----");
    print(vod);
    return JSON.stringify(vod)
}

function search(wd, quick) {
    print(__drives);
    print("可搜索的alist驱动:" + searchDriver);
    if (!searchDriver || !wd) {
        return JSON.stringify({
            list: []
        })
    } else {
        let driver = __drives[searchDriver];
        wd = wd.split(" ").filter(it => it.trim()).join("+");
        print(driver);
        driver.vods = getAllVods("box=" + wd, driver.name).list;
        return JSON.stringify({
            page: 1,
            pagecount: 1,
            list: driver.vods
        });
    }
}

function get_size(sz) {
    if (sz <= 0) {
        return ""
    }
    let filesize = "";
    if (sz > 1024 * 1024 * 1024 * 1024) {
        sz /= 1024 * 1024 * 1024 * 1024;
        filesize = "TB"
    } else if (sz > 1024 * 1024 * 1024) {
        sz /= 1024 * 1024 * 1024;
        filesize = "GB"
    } else if (sz > 1024 * 1024) {
        sz /= 1024 * 1024;
        filesize = "MB"
    } else if (sz > 1024) {
        sz /= 1024;
        filesize = "KB"
    } else {
        filesize = "B"
    }
    let sizeStr = sz.toFixed(2) + filesize,
        index = sizeStr.indexOf("."),
        dou = sizeStr.substr(index + 1, 2);
    if (dou === "00") {
        return sizeStr.substring(0, index) + sizeStr.substr(index + 3, 2)
    } else {
        return sizeStr
    }
}

function levenshteinDistance(str1, str2) {
    return 100 - 100 * distance(str1, str2) / Math.max(str1.length, str2.length)
}

function naturalSort(options) {
    if (!options) {
        options = {}
    }
    return function (a, b) {
        if (options.key) {
            a = a[options.key];
            b = b[options.key]
        }
        var EQUAL = 0;
        var GREATER = options.order === "desc" ? -1 : 1;
        var SMALLER = -GREATER;
        var re = /(^-?[0-9]+(\.?[0-9]*)[df]?e?[0-9]?$|^0x[0-9a-f]+$|[0-9]+)/gi;
        var sre = /(^[ ]*|[ ]*$)/g;
        var dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/;
        var hre = /^0x[0-9a-f]+$/i;
        var ore = /^0/;
        var normalize = function normalize(value) {
            var string = "" + value;
            return options.caseSensitive ? string : string.toLowerCase()
        };
        var x = normalize(a).replace(sre, "") || "";
        var y = normalize(b).replace(sre, "") || "";
        var xN = x.replace(re, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0");
        var yN = y.replace(re, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0");
        if (!x && !y) return EQUAL;
        if (!x && y) return GREATER;
        if (x && !y) return SMALLER;
        var xD = parseInt(x.match(hre)) || xN.length != 1 && x.match(dre) && Date.parse(x);
        var yD = parseInt(y.match(hre)) || xD && y.match(dre) && Date.parse(y) || null;
        var oFxNcL, oFyNcL;
        if (yD) {
            if (xD < yD) return SMALLER;
            else if (xD > yD) return GREATER
        }
        for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
            oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
            oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
            if (isNaN(oFxNcL) !== isNaN(oFyNcL)) return isNaN(oFxNcL) ? GREATER : SMALLER;
            else if (typeof oFxNcL !== typeof oFyNcL) {
                oFxNcL += "";
                oFyNcL += ""
            }
            if (oFxNcL < oFyNcL) return SMALLER;
            if (oFxNcL > oFyNcL) return GREATER
        }
        return EQUAL
    }
}
const sortListByName = (vodList, key, order) => {
    if (!key) {
        return vodList
    }
    order = order || "asc";
    return vodList.sort(naturalSort({
        key: key,
        order: order,
        caseSensitive: true
    }))
};
const getTimeInt = timeStr => {
    return new Date(timeStr).getTime()
};
const sortListByTime = (vodList, key, order) => {
    if (!key) {
        return vodList
    }
    let ASCarr = vodList.sort((a, b) => {
        a = a[key];
        b = b[key];
        return getTimeInt(a) - getTimeInt(b)
    });
    if (order === "desc") {
        ASCarr.reverse()
    }
    return ASCarr
};
const sortListBySize = (vodList, key, order) => {
    if (!key) {
        return vodList
    }
    let ASCarr = vodList.sort((a, b) => {
        a = a[key];
        b = b[key];
        return (Number(a) || 0) - (Number(b) || 0)
    });
    if (order === "desc") {
        ASCarr.reverse()
    }
    return ASCarr
};
export default {
    init: init,
    home: home,
    homeVod: homeVod,
    category: category,
    detail: detail,
    play: play,
    search: search
};
